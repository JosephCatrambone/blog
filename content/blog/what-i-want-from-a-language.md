---
title: 'What I Want from a Language'
description: ""
published: 2015-10-01
redirect_from: 
            - https://www.josephcatrambone.com/?p=779
categories: "Programming"
hero: ../../../defaultHero.jpg
---
Although I feel like I'm at a pretty comfortable place in my life with respect to programming languages (all the right tools for the right job), I'm still looking for the magical, silver bullet that can do everything I want with perfect convenience, high entertainment value, and minimal headache.

My current repertoire consists of Python for most prototyping and web applications, Java for desktop and games, and C for the occasional embedded and low-level stuff. Throw in some JavaScript for client-side things by necessity.

But not one of these is perfect in any sense of the word. They're all Ada-descendants, which is fine with me, aside from the nagging voice in my head and the choir of society saying 'try new things!'. I feel like my approach to learning new languages is less about learning the finer details of the language and more about figuring out stuff that can be done. For many of my programs, it's less about how I put together the application (like the ML exercises or games), and more a question of 'how would I do this mathematically?' Which means a language which is easier makes sense to me. I've experimented with dozens to get outside the comfort zone, Clojure, Haskell, Scheme, Elixr, C#, but none of them allow me to really think about the things I want to \_build\_. Perhaps/Probably because I'm too lazy to get fluent enough to get cozy.

But if I \_were\_ hoping for a perfect programming language, what would it be like? I'm not sure I can specify the syntax, but I can probably provide the feature set.

### Compiled or JVM Compatible

No interpreter. Python is a great language. I use it regularly and it's still entertaining, but distribution is a total pain in the ass. It lets me build decent web applications with great ease, lets me do anything I want with matrix multiplications and machine learning, and the venv/PIP combo is a great ecosystem. Distribution, though. Goddamn. You can't compile a Python app to native. You can't build a statically linked library. You can't build a DLL. You can't make assembly code for an IC. Well, okay, you kinda' can, but it's not great. I just want an application which can compile down to fast, native code. Better yet, let me use one compiler on Windows or OSX or Linux and build for ALL THE OTHER PLATFORMS. That would be fantastic. Excluding that, I suppose I can accept building for the JVM.

### Linear Algebra Library and Operators

Java also fits a lot of these, and it's a bit more boilerplate heavy when it comes to web applications (Jetty? Netty? Grizzly? Glassfish? Tomcat? Containers? Servlets? Oh my!) but it's really the De Facto industry standard. It also is awesome when it comes to distributions. Some people whine about installing the JVM, and I don't blame them. Java Devs don't notice the problem because the JDK doesn't include any of the Ask toolbar nonsense. You do what you can. But I digress, Linear Algebra Libraries. Python has numpy, which works brilliantly and Java has kinda' jblas, along with a bunch of others. The Java language, though, doesn't support operator overloading, for better or worse. That means you're left with a.mmul(Matrix.ones(b.getRows(), b.getColumns()).transpose().div(b)).transpose().div(c) instead of a\*(1.0/b).T/c. Huge problem? Not really, but it does make it that much harder to transliterate. In a very similar sense, it helps to have one standard image library that gives me pixel-level access and a few useful methods to go from disk image -> picture -> matrix -> picture -> disk image.

### Static Typing

Again we come to Python. I actually really hate inferring type. It might mean more writing in Java when it comes to saying DoubleMatrix derp, but it's really helpful to be able to say, "I EXPECT TYPE DOUBLEMATRIX" when I need it. This is especially helpful when you're getting data from a web application and you can't tell if some middleware has cast a variable from an integer to a string.

### Easy or Automatic Parallelization

Part of me misses the OPENMP decorater from C++ and C. Being able to say \`#pragma omg parallel\` and know that you're automatically going to spin up stuff on a bunch of cores is profoundly satisfying. At the same time, I like the ease with which Java lets me spin up a thread and say, "Do thing in the background until I join." C's threadding library isn't terrible, but Java really has it down nicely. I find myself lusting after ParallelFor in Java (which is getting better thanks to JDK8) and missing Threads when working in C. Combining this with the Linear Algebra library above would be an absolute godsend, especially if the program can GPU or FPGA parallelize things.

### Superb Ecosystem and Tools

This probably goes without saying, but having a compiler which points out a line problem, a debugger which lets you step, and a REPL which lets you play can do amazing things. Being able to say, "pip install without worrying is also a great touch. Gradle is a great piece of this, since it gives a lot of the flexibility of Make scripts without the bullshit package management.

### Simple, Iteratively Deepening Syntax

Haskell is a cool tool, but it's a lot to take in at the same time. With Python, I was able to start and experiment simply in the style that I was accustomed to, doing simple for-loops and such. Eventually, moving up to stuff like \`blah_map = {x\[0]:x\[1] for x in itertools.product(foo, bar)}\`. Being able to start somewhat familiarly helps a lot, since, as mentioned above, I'm the type that cares more about the product and the math than the tools themselves.

Too much to ask? Probably, but I'm excited to see what the future holds.
